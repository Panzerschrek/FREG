	/*
	*This file is part of Eyecube.
	*
	*Eyecube is free software: you can redistribute it and/or modify
	*it under the terms of the GNU General Public License as published by
	*the Free Software Foundation, either version 3 of the License, or
	*(at your option) any later version.
	*
	*Eyecube is distributed in the hope that it will be useful,
	*but WITHOUT ANY WARRANTY; without even the implied warranty of
	*MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	*GNU General Public License for more details.
	*
	*You should have received a copy of the GNU General Public License
	*along with Eyecube. If not, see <http://www.gnu.org/licenses/>.
	*/

#include <ncurses.h>
#include <unistd.h>

#define DEBUG 1

enum color_pairs {
	BLACK_BLACK=1,
	BLACK_RED,
	BLACK_GREEN,
	BLACK_YELLOW,
	BLACK_BLUE,
	BLACK_MAGENTA,
	BLACK_CYAN,
	BLACK_WHITE,
	//
	RED_BLACK,
	RED_RED,
	RED_GREEN,
	RED_YELLOW,
	RED_BLUE,
	RED_MAGENTA,
	RED_CYAN,
	RED_WHITE,
	//
	GREEN_BLACK,
	GREEN_RED,
	GREEN_GREEN,
	GREEN_YELLOW,
	GREEN_BLUE,
	GREEN_MAGENTA,
	GREEN_CYAN,
	GREEN_WHITE,
	//
	YELLOW_BLACK,
	YELLOW_RED,
	YELLOW_GREEN,
	YELLOW_YELLOW,
	YELLOW_BLUE,
	YELLOW_MAGENTA,
	YELLOW_CYAN,
	YELLOW_WHITE,
	//
	BLUE_BLACK,
	BLUE_RED,
	BLUE_GREEN,
	BLUE_YELLOW,
	BLUE_BLUE,
	BLUE_MAGENTA,
	BLUE_CYAN,
	BLUE_WHITE,
	//
	MAGENTA_BLACK,
	MAGENTA_RED,
	MAGENTA_GREEN,
	MAGENTA_YELLOW,
	MAGENTA_BLUE,
	MAGENTA_MAGENTA,
	MAGENTA_CYAN,
	MAGENTA_WHITE,
	//
	CYAN_BLACK,
	CYAN_RED,
	CYAN_GREEN,
	CYAN_YELLOW,
	CYAN_BLUE,
	CYAN_MAGENTA,
	CYAN_CYAN,
	CYAN_WHITE,
	//
	WHITE_BLACK,
	WHITE_RED,
	WHITE_GREEN,
	WHITE_YELLOW,
	WHITE_BLUE,
	WHITE_MAGENTA,
	WHITE_CYAN,
	WHITE_WHITE,
};
enum weathers {
	CLEAR,
	RAIN,
	SNOW,
	HAIL,
	FROGS
};
enum directions {
	NORTH,
	SOUTH,
	EAST,
	WEST
};
enum subs {
	STONE,
	SOIL,
	PLAYER,
	OTHER_PLAYER,
	BALL
};

const int shred_width=100;//TODO make variables
const int height=100;
const int screen_width=21;
const int note_length=145;
const char skymap[screen_width][screen_width+1]={
	"   ..  .. .      ..  ",
	"       .        .    ",
	"   .     .   .   .   ",
	" ..     .   .    .  .",
	"     . . .     . ..  ",
	" .. .  .    .    .   ",
	" .              .    ",
	"   .          .      ",
	"     .   ..    .     ",
	".        .      ..   ",
	" .       .       .   ",
	"                     ",
	" .      .   .     .  ",
	"       ...  .        ",
	"      .     .   .    ",
	".  ....       ..   ..",
	"          .        . ",
	"   .    ..  . .    ..",
	"  .      .           ",
	"              .     .",
	".      .   ...  .   ."
};
const int prec_prob=20;

int random_prob(short prob) {
	FILE *file=fopen("/dev/urandom", "rb");
	char c=fgetc(file);
	fclose(file);
	return (128+c<prob*2.55) ? 1 : 0;
}

class Block {
	subs id;
	unsigned short health;
	unsigned short durability;
	//char * note;
	public:
	bool transparent;
	/*void WriteNote(const char * const text) {
		note=new char[note_length];
		strncpy(note, text, note_length-1);
		note[note_length-1]='\0';
	}*/
	//virtual void Push() {};
	//virtual void Use() {};
	/*virtual bool Destroy(unsigned short damage) {
		return ((health-=damage)<=0);
	}*/
	char Name() {
		switch (id) {
			case STONE: return '#'; break;
			default: return '?'; break;
		}
	}
	color_pairs Color() {
		switch (id) {
			case SOIL:  return BLACK_GREEN;
			case STONE: return BLACK_WHITE;
			default:    return WHITE_BLACK;
		}
	}
	/*Block(subs n) : transparent(false), health(100) {
	}*/
	void * operator new(size_t size, subs n) {
		Block * newblock=::new Block;
		newblock->transparent=false;
		newblock->health=100;
		newblock->id=n;
		switch (n) {
			case STONE: newblock->durability=10; break;
			default: newblock->durability=1; break;
		}
		return newblock;
	}
	virtual ~Block() {}
};

class World {
	long planet_x, planet_y; //player's current shred coordinates
	/*there isn't the only way for light from one point to another
	 *this finds one of them, and it is not the straight line.*/
	/*int visible3(short x, short y, short z,
	             short xtarget, short ytarget, short ztarget) {
		if (x==xtarget && y==ytarget && z==ztarget) return 1;
		else if ( !*blocks[x][y][s]->transparent ) return 0;
		else {
			if (x!=xtarget) x+=(xtarget>x) ? 1 : -1;
			if (y!=ytarget) y+=(ytarget>y) ? 1 : -1;
			if (z!=ztarget) z+=(ztarget>z) ? 1 : -1;
			return visible3(x, y, z, xtarget, ytarget, ztarget);
		}
	}*/
	public:
	//Block * blocks[shred_width*3][shred_width*3][height];
	unsigned short x, y, z;
	struct sound {
		char snd;//sound character
		char lev;//sound level
	} sounds[3][3];
	int moon_left() {//will form different forms of the moon depending on time
		return '(';
	}
	int moon_right() {
		return ')';
	}
	unsigned long time; //global game world time
	weathers weather;
	/*int visible2x3(short x1, short y1, short z1,
	               short x2, short y2, short z2) {
		short savecor;
		if (visible3(x1, y1, z1, x2, y2, z2)) return 1;
		else if ((x2!=x1 && transparent(x2+(savecor=(x2>x1) ? (-1) : 1), y2, z2)
			&& visible3(x1, y1, z1, x2+savecor, y2, z2)) ||
			(y2!=y1 && transparent(x2, y2+(savecor=(y2>y1) ? (-1) : 1), z2)
			&& visible3(x1, y1, z1, x2, y2+savecor, z2)) ||
			(z2!=z1 && transparent(x2, y2, z2+(savecor=(z2>z1) ? (-1) : 1))
			&& visible3(x1, y1, z1, x2, y2, z2+savecor))) return 1;
		else return 0;
	}*/
	World() {
		//TODO connect, get map, rewrite all costructor
		planet_x=0;
		planet_y=0;
		x=y=1.5*shred_width;
		z=height/2;
		time=5*60;
		weather=CLEAR;
		puts("allok");
		/**blocks[shred_width+10][shred_width+7][height/2]=STONE;
		*blocks[shred_width+15][shred_width+9][height/2]=STONE;
		*blocks[shred_width+9][shred_width+9][height/2]=STONE;
		*blocks[shred_width+15][shred_width+17][height/2]=STONE;*/
		unsigned short i, j, k;
	/*	for (i=0; i<shred_width*3; ++i)
		for (j=0; j<shred_width*3; ++j) {
			for (k=0; k<height/4; ++k) blocks[i][j][k]=new (STONE) Block;
			for (   ; k<height/2; ++k) blocks[i][j][k]=new (SOIL) Block;
			for (   ; k<height;   ++k) blocks[i][j][k]=NULL;//air
		}*/
		/*for (i=0; i<3; ++i)
		for (j=0; j<3; ++j) {
			sounds[i][j].snd=' ';
			sounds[i][j].lev=' ';
		}
		sounds[0][2].snd='c';
		sounds[0][2].lev='+';*/
	}
	~World() {
/*		unsigned short i, j, k;
		for (i=0; i<shred_width*3; ++i)
		for (j=0; j<shred_width*3; ++j)
		for (k=0; k<height; ++k)
			if (blocks[i][j][k]!=NULL) delete blocks[i][j][k];*/
	}
	void proc_key(int ch) {};
};

/*class Screen {
	enum right_views {
		VIEW_NORTH,
		VIEW_EAST,
		VIEW_SOUTH,
		VIEW_WEST,
		VIEW_MENU,
		VIEW_INVENTORY,
		VIEW_CHEST,
		VIEW_WORKBENCH,
		VIEW_FURNACE
	} right_view;
	enum left_views {
		VIEW_SKY,
		VIEW_EARTH,
		VIEW_MIDDLE
	} left_view;
	WINDOW * world_left_win, * world_right_win, * pocket_win, * text_win, * sound_win;
	void print_env(WINDOW * print_win, World & W) {
		short x, y, z,
		      * i, * j, * k,
		      idir, jdir, kdir,
		      kbound, coor;
		if (world_left_win==print_win) {//set variables
			i=&(x=W.x-10);
			j=&(y=W.y-10);
			idir=1;
			jdir=1;
			coor=W.z;
			if (VIEW_SKY==left_view) {
				k=&(z=W.z+1);
				kdir=1;
				kbound=height;
			} else {
				k=&(z=height-1);
				kdir=-1;
				kbound=-1;
			}
		} else {
			j=&(z=W.z+19);
			jdir=-1;
			switch (right_view) {
				case VIEW_NORTH:
					i=&(x=W.x-10);
					idir=1;
					coor=W.y;
					k=&(y=W.y-1);
					kdir=-1;
					kbound=-1;
				break;
				case VIEW_SOUTH:
					i=&(x=W.x+10);
					idir=-1;
					coor=W.y;
					k=&(y=W.y+1);
					kdir=1;
					kbound=shred_width*3;
				break;
				case VIEW_WEST:
					i=&(y=W.y+10);
					idir=-1;
					coor=W.x;
					k=&(x=W.x-1);
					kdir=-1;
					kbound=-1;
				break;
				case VIEW_EAST:
					i=&(y=W.y-10);
					idir=1;
					coor=W.x;
					k=&(x=W.x+1);
					kdir=1;
					kbound=shred_width*3;
				break;
			}
		}
		unsigned short scrx, scry, ksave=*k, jsave=*j;
		for (scrx=1;           scrx<=screen_width*2-1; scrx+=2, *i+=idir)
		for (scry=1, *j=jsave; scry<=screen_width;   ++scry,    *j+=jdir) {
			for (*k=ksave ; *k!=kbound; *k+=kdir)
				if ( W.blocks[x][y][z]!=NULL && !W.blocks[x][y][z]->transparent ) {
					if ( true )//W.visible2x3(W.x, W.y, W.z, x, y, z) ) {
						char ch;
						//set second character
						if (world_left_win==print_win) {
							if (*k<coor-2) ch='!';
							else if (*k==coor-2) ch='_';
							else if (*k==coor-1) ch=' ';
							else if (*k<coor+9)
								ch='0'+*k-coor+1;
							else ch='+';
						} else {
							if (*k==coor+kdir) ch=' ';
							else if (kdir*(*k-coor)<11)
								ch='0'+kdir*(*k-coor)-1;
							else ch='+';
						}
						wattrset( print_win,
							COLOR_PAIR(W.blocks[x][y][z]->Color()) );
						mvwprintw( print_win, scry, scrx, "%c%c",
							W.blocks[x][y][z]->Name(), ch );
					} else {
						wstandend(print_win);
						mvwprintw(print_win, scry, scrx, "  ");
					}
					break;
				}
			if (*k==kbound) { *k-=kdir;
			if ( true )//W.visible2x3(W.x, W.y, W.z, x, y, z) ) {
				if (world_left_win==print_win) {
					if (W.weather!=CLEAR && random_prob(prec_prob))
						switch (W.weather) {
							case RAIN:
				wattrset(print_win, (W.time%(24*60)<6*60) ?
					COLOR_PAIR(BLUE_BLACK) : COLOR_PAIR(BLUE_CYAN));
				mvwprintw(print_win, scry, scrx, ", ");
							break;
							case SNOW:
				wattrset(print_win, (W.time%(24*60)<6*60) ?
					COLOR_PAIR(WHITE_BLACK) : COLOR_PAIR(WHITE_CYAN));
				mvwprintw(print_win, scry, scrx, "* ");
							break;
							case HAIL:
				wattrset(print_win, (W.time%(24*60)<6*60) ?
					COLOR_PAIR(WHITE_BLACK) : COLOR_PAIR(WHITE_CYAN));
				mvwprintw(print_win, scry, scrx, "o ");
							break;
							case FROGS:
				wattrset(print_win, (W.time%(24*60)<6*60) ?
					COLOR_PAIR(GREEN_BLACK) : COLOR_PAIR(GREEN_CYAN));
				mvwprintw(print_win, scry, scrx, "f ");
						}
					else if (W.time%(24*60)<6*60) {
						wattrset(print_win,
							COLOR_PAIR(WHITE_BLACK));
						mvwprintw(print_win, scry, scrx, "%c ",
							skymap[scry-1][scrx/2-1]);
					} else {
						wattrset(print_win,
							COLOR_PAIR(WHITE_CYAN));
						mvwprintw(print_win, scry, scrx, "  ");
					}
				} else {
					wattrset(print_win, COLOR_PAIR(BLACK_WHITE));
					mvwprintw(print_win, scry, scrx, "  ");
				}
			}}
		}
		if (world_left_win==print_win)//print player and sun or moon
			if (left_view==VIEW_SKY) {
				wstandend(print_win);
				mvwprintw(print_win, screen_width/2+1, 0, ">");
				mvwprintw(print_win, screen_width/2+1,
					screen_width*2+1, "<");
				mvwprintw(print_win, screen_width+1, screen_width, "^^");
				mvwprintw(print_win, 0, screen_width, "vv");
				if ( W.time%(24*60)>6*60 ) {//sun
					wattrset(print_win, COLOR_PAIR(BLACK_YELLOW));
					mvwprintw(print_win, screen_width/2+1,
						( (screen_width*2*((W.time%(24*60))-6*60))
						/(18*60)+1 ), "  ");
				} else {//moon
					wattrset(print_win, COLOR_PAIR(BLACK_WHITE));
					mvwprintw( print_win, screen_width/2+1,
						( (screen_width*2*(W.time%(24*60)))
						/(6*60)+1 ), "%c%c",
						W.moon_left(), W.moon_right() );
				}
			} else {
				char ch;
				switch (right_view) {
					case VIEW_NORTH: ch='^'; break;
					case VIEW_SOUTH: ch='v'; break;
					case VIEW_WEST:  ch='<'; break;
					case VIEW_EAST:  ch='>'; break;
					default: ch=' '; break;
				}
				wattrset(print_win, COLOR_PAIR(WHITE_BLUE));
				mvwprintw(print_win, screen_width/2+1, screen_width,
					"@%c", ch);
			}
		else {//print player locating arrows
			wstandend(print_win);
			mvwprintw(print_win, screen_width-1,            0, ">");
			mvwprintw(print_win, screen_width-1, screen_width*2+1, "<");
			mvwprintw(print_win, screen_width+1,   screen_width, "^^");
		}
	}
	public:
	Screen() {
		set_escdelay(10);
		initscr();
		start_color();
		raw();
		noecho();
		keypad(stdscr, TRUE);
		curs_set(0);
		init_pair(BLACK_BLACK,  COLOR_BLACK,  COLOR_BLACK );
		init_pair(BLACK_RED,    COLOR_BLACK,  COLOR_RED   );
		init_pair(BLACK_GREEN,  COLOR_BLACK,  COLOR_GREEN );
		init_pair(BLACK_YELLOW, COLOR_BLACK,  COLOR_YELLOW);
		init_pair(BLACK_BLUE,   COLOR_BLACK,  COLOR_BLUE  );
		init_pair(BLACK_CYAN,   COLOR_BLACK,  COLOR_CYAN  );
		init_pair(BLACK_WHITE,  COLOR_BLACK,  COLOR_WHITE );
		//
		init_pair(RED_BLACK,    COLOR_RED,    COLOR_BLACK );
		init_pair(RED_YELLOW,   COLOR_RED,    COLOR_YELLOW);
		init_pair(RED_BLUE,     COLOR_RED,    COLOR_BLUE  );
		init_pair(RED_CYAN,     COLOR_RED,    COLOR_CYAN  );
		init_pair(RED_WHITE,    COLOR_RED,    COLOR_WHITE );
		//
		init_pair(GREEN_BLACK,  COLOR_GREEN,  COLOR_BLACK );
		init_pair(GREEN_CYAN,   COLOR_GREEN,  COLOR_CYAN  );
		//
		init_pair(YELLOW_RED,   COLOR_YELLOW, COLOR_RED   );
		//
		init_pair(BLUE_BLACK,   COLOR_BLUE,   COLOR_BLACK );
		init_pair(BLUE_YELLOW,  COLOR_BLUE,   COLOR_YELLOW);
		init_pair(BLUE_CYAN,    COLOR_BLUE,   COLOR_CYAN  );
		//
		init_pair(WHITE_BLACK,  COLOR_WHITE,  COLOR_BLACK );
		init_pair(WHITE_BLUE,   COLOR_WHITE,  COLOR_BLUE  );
		init_pair(WHITE_CYAN,   COLOR_WHITE,  COLOR_CYAN  );
		world_left_win =newwin(23, 44,  0,  0);
		world_right_win=newwin(23, 44,  0, 44);
		pocket_win     =newwin( 1, 44, 23,  0);
		text_win       =newwin( 5, 36, 24,  8);
		sound_win      =newwin( 5,  8, 24,  0);
		right_view=VIEW_EAST;
		left_view=VIEW_SKY;
		refresh();
	}
	void map(World & W) {
		wclear(world_left_win);
		wclear(world_right_win);
		//
		wstandend(world_left_win);
		wstandend(world_right_win);
		//
		box(world_left_win,  0, 0);
		box(world_right_win, 0, 0);
		//
		print_env(world_left_win,  W);
		print_env(world_right_win, W);
		//
		wrefresh(world_left_win);
		wrefresh(world_right_win);
	}
	void notify(const char * n) {
		wclear(text_win);
		wstandend(text_win);
		mvwaddstr(text_win, 1, 1, n);
		box(text_win, 0, 0);
		wrefresh(text_win);
	}
	void print_sounds(World & W) {
		wclear(sound_win);
		char ch;
		short i=0, j;
		while (i<3) {
			for (j=0; j<3; ++j)
				mvwprintw(sound_win, j+1, i*2+1, "%c%c",
					W.sounds[i][j].snd, W.sounds[i][j].lev);
			mvwaddch(sound_win, j+1, i*2+1, '\n');
			++i;
		}
		box(sound_win, 0, 0);
		wrefresh(sound_win);
	}
	void print_pocket(World & W) {};
	~Screen() {
		delwin(world_left_win);
		delwin(world_right_win);
		delwin(text_win);
		delwin(pocket_win);
		delwin(sound_win);
		endwin();
	}
};*/

int main(int argc, char *argv[]) {
	World earth;
//	Screen scr;
//	scr.map(earth);
//	scr.notify("Game started.");
//	scr.print_sounds(earth);
	int ch;
	while ( (ch=getch())!='Q' ) {
		//proc_key(ch);
//		scr.map(earth);
//		usleep(10000);
	}
}
